---
title: "An Introduction to zitools"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{rmarkdown::render}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Installation

You can install the development version of zitools from GitHub with:

```{r, eval = FALSE}
devtools::install_github("kreutz-lab/zitools")
```

# Introduction

This vignette provides an introductory example on how to work with the 'zitools' package, which implements a weighting strategy based on a fitted zero inflated mixture model.

Step one: load required packages

```{r}
library(zitools)
library(phyloseq)
```

## ziMain function

zitools is a package to analyse zero inflated count data, such as microbiome data. As default structural zeros are estimated from counts using features (=rows) and samples (=columns) as factorial predictor variables when fitting a zero inflated poisson or zero inflated negative binomial model.

```{r}
ps <- readRDS("C:/Users/meyerinc/Masterarbeit/cdi_schubert_results.rds")
ps <- filter_taxa(ps, function(x) sum(x > 0) > (0.2*length(x)), TRUE)
otu_table(ps) <- otu_table(ps)[,1:168]
otu_table(ps) <- otu_table(ps)[rowSums(otu_table(ps))>0,]

res_ps <- ziMain(ps, feature = "OTU", formula = count ~ sample + OTU, dist = "negbin", link = "logit", zeroRows.rm = TRUE)

```

### Boxplots
The generic boxplot function is overloaded and plots zero-deinflated counts (by default along columns, i.e. one box is plotted for each sample.

Plotting the zero-inflated input counts for comparison illustrates the effect of zero-deinflation.

```{r}
boxplot(log2p(res_ps)) # deinflated counts
boxplot(log2p(res_ps@inputcounts)) # plotting zero-inflated counts

heatmap(res_ps, Rowv=NULL, Colv=NULL)
```

Plotting boxes for each feature can easily be done by applying transpose 
```{r}
boxplot(t(res_ps))
boxplot(t(res_ps@deinflatedcounts)) # equivalent
```

Individual data points can be plotted by the overloaded generic plot function:
```{r}
plot(res_ps)
plot(res_ps,xlab="First sample [counts]",ylab="Second sample [counts]") # equivalent
```

Plotting all data points:
```{r}
plot(as.vector(Zi@deinflatedcounts),xlab="Index",ylab="counts")
```

### Principal component analysis (PCA)

Zero-inflation can be accounted in PCA by calculating correlations with weights and then calculating principal components from these correlations.

```{r}
# compare 2 possible calls of princomp:
princomp(covmat=cor(Zi@inputdata))[["sdev"]]-princomp(Zi@inputdata,cor=T)[["sdev"]] # same
# PCA with downweighting structrual zeros:
princomp(covmat=cor(Zi))  
```



### Differential Abundance Analysis - with weights

```{r}
deseq_zi <- zi_to_deseq2(res_ps, ~disease_stat)
dds_zi <-  DESeq(dds_zi, test = "Wald", fitType = "local", sfType = "poscounts")

plotMA(dds_zi)
plotDispEsts(dds_zi)

res_zi <- results(dds_zi, cooksCutoff = FALSE)
res_zi

df_res_zi <- cbind(as(res_zi, "data.frame"), as(tax_table(ps)[rownames(res_zi), ], "matrix"))
df_res_zi <- df_res_zi %>%
  rownames_to_column(var = "OTU") %>%
  arrange(padj)

(fdr_otu_zi <- df_res_zi %>%
  dplyr::filter(padj < 0.1)) 
```

### Differential Abundance Analysis - without weights

```{r}
deseq <- phyloseq_to_deseq2(ps, ~disease_stat)
dds <-  DESeq(deseq, test = "Wald", fitType = "local", sfType = "poscounts")

res <- results(dds, cooksCutoff = FALSE)
res

df_res<- cbind(as(res, "data.frame"), as(tax_table(ps)[rownames(res), ], "matrix"))
df_res <- df_res %>%
  rownames_to_column(var = "OTU") %>%
  arrange(padj)
df_res

(fdr_otu <- df_res %>%
  dplyr::filter(padj < 0.1)) 
```
